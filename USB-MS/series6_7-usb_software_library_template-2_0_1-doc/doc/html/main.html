<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ATMEL: AT90USBxxx USB software library for dual role devices</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1>AT90USBxxx USB software library for dual role devices</h1>
<p>
<h2><a class="anchor" name="intro">
License</a></h2>
Use of this program is subject to Atmel's End User License Agreement.<p>
Please read file <a class="el" href="lic_page.html">LICENSE.TXT</a> for copyright notice.<h2><a class="anchor" name="install">
Description</a></h2>
This embedded application source code illustrates how to implement a USB interfaced application over the AT90USBxxx controller.<p>
As the AT90USBxxx implements a device/host usb controller, the embedded application can operates in one of the following usb operating modes:<ul>
<li>USB device</li><li>USB reduced host controller</li><li>USB dual role device (depending on the ID pin)</li></ul>
<p>
To optimize embedded code/ram size and reduce the number of source modules, the application can be configured to use one and only one of these operating modes.<p>
This sample application can be configured for both STK525 or AT90USBKey hardware, see <a class="el" href="a00074.html#g9621e9ad9974752837d9c49cb8c03a7e" title="Enable or not the ADC usage.">TARGET_BOARD</a> define value in <a class="el" href="a00024.html">config.h</a> file.<h2><a class="anchor" name="src_code">
About the source code</a></h2>
This source code is usable with the following compilers:<ul>
<li>IAR Embedded Workbench (5.11A and higher)</li><li>AVRGCC (WinAVR 20080411 and higher).</li></ul>
<p>
Support for other compilers may required modifications or attention for:<ul>
<li><a class="el" href="a00021.html">compiler.h</a> file</li><li>special registers declaration file</li><li>interrupt subroutines declarations</li></ul>
<h2><a class="anchor" name="Revision">
Revision</a></h2>
<dl class="user" compact><dt><b>V2.0.1</b></dt><dd></dd></dl>
USB Stack<ul>
<li>Add three possibilities for SN on USB</li><li>Move VBus interrupt to VBus pooling</li><li>Fix USB constant about Device Status</li><li>Improve USB protocol to have a USB chap9 compliance</li></ul>
<p>
New watchdog driver<p>
<dl class="user" compact><dt><b>V2.0.0 and before</b></dt><dd>Old versions</dd></dl>
<h2><a class="anchor" name="sample">
About the sample application</a></h2>
By default the sample code is delivered with a simple preconfigured dual role USB application. It means that the code generated allows to operate as a device or a host depending on the USB ID pin:<ul>
<li>Attached to a mini B plug (ID pin unconnected) the application will be used in the device operating mode</li><li>Attached to a mini A plug (ID pin tied to ground) the application will operate in reduced host mode</li></ul>
<p>
<div align="center">
<img src="appli.gif" alt="appli.gif">
</div>
 Thus two instances of this application can be connected together with a miniA-miniB cable.<ul>
<li>The host operating mode of the application (that we call A device) can manage the connection and the enumeration of a device application connected in device operating mode (that we call B device). Once the device has been enumerated, the host high level application can operate USB applicative exchanges with the B device. Here the sample host application writes 64 byte through a USB OUT pipe and read back these data with an IN pipe.</li><li>The device operating mode of the application (B device) answers to the enumeration requests (setup requests) of the host controller. Once it has been properly enumerated the high level device application receives 64 data through its OUT enpoint and when the host controller request for an IN exchange on its IN endpoints, sends it back (loopback application).</li></ul>
<h2><a class="anchor" name="arch">
Architecture</a></h2>
As illustrated in the figure bellow, the application entry point is located is the <a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">main.c</a> file. The main function first performs the initialization of a scheduler module and then runs it in an infinite loop. The scheduler is a simple infinite loop calling all its tasks defined in the <a class="el" href="a00022.html">conf_scheduler.h</a> file. No real time schedule is performed, when a task ends, the scheduler calls the next task defined in the configuration file (<a class="el" href="a00022.html">conf_scheduler.h</a>).<p>
The sample dual role application is based on three different tasks:<ul>
<li>The usb_task (<a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">usb_task.c</a> associated source file), is the task performing the USB low level enumeration process in device or host mode. Once this task has detected that the usb connection is fully operationnal, it updates different status flags that can be check within the high level application tasks.</li><li>The device template task (<a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">device_template_task.c</a> associated source file) performs the high level device application operation. Once the device is fully enumerated (DEVICE SETUP_SET_CONFIGURATION request received), the task checks for received data on its OUT endpoint and transmit these data on its IN endpoint.</li><li>The host template tak (<a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">host_template_task.c</a> associated file) performs the high level host application operation. Ih the "B device" is correctly connected and enumerated, the task sends and receives data with the USB bus.</li></ul>
<p>
<div align="center">
<img src="arch_full.gif" alt="arch_full.gif">
</div>
<h2><a class="anchor" name="config">
Configuration</a></h2>
The sample application is configured to implements both host and device functionnalities. Of course it can also be configured to be used in device or reduced host only mode (See <a class="el" href="a00023.html">conf_usb.h</a> file). Depending on the USB operating mode selected, the USB task will call either the usb_host_task (<a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">usb_host_task.c</a>), either the usb device task (<a class="el" href="a00054.html#59be438694d50e32414315b30318c0c8">usb_device_task.c</a>) to manage chapter 9 requests. In such case, the corresponding template_device_task or template_host_task can be removed from the scheduled tasks (see <a class="el" href="a00022.html">conf_scheduler.h</a>). <dl class="note" compact><dt><b>Note:</b></dt><dd>The B device descriptors used for this sample application are not directly usable for enumeration with a standard Pc host system. Please refers to <a href="http://www.atmel.com">ATMEL website </a> for real devices applications examples (HID mouse, HID keyboard, MassStorage, CDC ... )</dd></dl>
<dl compact><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Implements the required mechanism for On the Go (OTG) compliance: SRP, HNP and role exchange detection/requests.</dd></dl>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 3 10:08:23 2008 for ATMEL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
